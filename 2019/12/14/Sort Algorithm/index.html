<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><meta name="keywords" content="vue"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><link rel="stylesheet" type="text/css" href="https://unpkg.com/gitalk/dist/gitalk.css?v=2.0.4"><title>Sort Algorithm | EagleLee</title><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Sort Algorithm</h1><a id="logo" href="/.">EagleLee</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="search"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Sort Algorithm</h1><div class="post-meta"><a href="/2019/12/14/Sort%20Algorithm/#comments" class="comment-count"></a><p><span class="date">Dec 14, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Hits</i></i></span></p></div><div class="post-content"><h1 id="排序算法-考研数据结构"><a href="#排序算法-考研数据结构" class="headerlink" title="排序算法-考研数据结构"></a><center>排序算法-考研数据结构<center></center></center></h1><blockquote>
<p> &emsp;&emsp;所谓排序，即将原本无序的序列重新排列成有序序列的过程。这个序列中的每一项可能是单独的数据元素，也可能是一条记录(记录是由多个数据元素组成的，如一个学生记录就是由学号、姓名、年龄、专业等数据元素组成的)。<a id="more"></a>如果是记录，则既可以按照记录的主关键字排序(主关键字唯一标识一条记录，如学生记录中的学号就是主关键字，学号不能重复，用来唯一标识一个学生)，也可以按照记录的次关键字排序(如学生记录中的姓名、专业等都是次关键字，次关键字是可以重复的)。<br>&emsp;&emsp;而稳定性是指当待排序序列中有两个或两个以上相同的关键字时，排序前和排序后这些关键字的相对位置，如果没有发生变化就是稳定的，否则就是不稳定的。例如，某序列有两个关键字都是50，以50(a)和50(b)来区分它们，用某种算法A对其排序，排序前50(a)在50(b)之前，如果排序后50(a)仍然在50(b)之前，则A是稳定的；如果能找出一种情况，使排序后50(a)在50(b)之后，则A是不稳定的。如果关键字不能重复，则排序结果是唯一的，那么选择的排序算法稳定与否就无关紧要；如果关键字可以重复，则在选择排序算法时，就要根据具体的需求采考虑选择稳定的还是不稳定的排序算法。</p>
</blockquote>
<h2 id="0、各排序算法的时间复杂度与空间复杂度及稳定性比较"><a href="#0、各排序算法的时间复杂度与空间复杂度及稳定性比较" class="headerlink" title="0、各排序算法的时间复杂度与空间复杂度及稳定性比较"></a>0、各排序算法的时间复杂度与空间复杂度及稳定性比较</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2019/12/14/Sort%20Algorithm/Ochat.png" alt="排序算法的时间复杂度与空间复杂度及稳定性比较" title="时间和空间复杂度及稳定性总结"></h2><h2 id="1、直接插入"><a href="#1、直接插入" class="headerlink" title="1、直接插入"></a>1、直接插入</h2><blockquote>
<p><strong><em>算法思想</em></strong>：每趟将一个待排序的关键字按照其值的大小插入到已经排好的部分有序序列的适当位置上，直到所有待排关键字都被插入到有序序列中为止。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		temp = R[i];  <span class="comment">//将待插入关键字暂存在temp中</span></span><br><span class="line">		j = i - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/*下面这个循环完成了从待排关键字之前的关键字开始扫描，如果大于待排关键字，则后移一位*/</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; R[j]) &#123;</span><br><span class="line">			R[j + <span class="number">1</span>] = R[j];</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">		R[j + <span class="number">1</span>] = temp;   <span class="comment">//找到插入位置，将temp中暂存的待排关键字插入</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//对排序了的数组输出</span></span><br><span class="line">	outPutArr(R, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2、希尔排序"><a href="#2、希尔排序" class="headerlink" title="2、希尔排序"></a>2、希尔排序</h2><blockquote>
<p><strong><em>算法思想</em></strong>：希尔排序又称之为缩小增量排序，其本质还是插入排序，只不过是将待排序列按照某种规则分成几个子序列，分别对这几个子序列进行直接插入排序。这个规则的体现就是增量的选取，希尔排序的时间复杂度为：O(n*logn)。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> gap = n/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; n; i++)&#123;</span><br><span class="line">			temp = R[i];</span><br><span class="line">			<span class="keyword">int</span> j;</span><br><span class="line">			<span class="keyword">for</span>(j = i; j &gt;= gap &amp;&amp; R[j-gap] &gt; temp; j -= gap)&#123;</span><br><span class="line">				R[j] = R[j-gap];</span><br><span class="line">			&#125;</span><br><span class="line">			R[j] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	outPutArr(R,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h2><blockquote>
<p><strong><em>算法思想</em></strong>：假设待排序表长为n，从后往前(或从前往后)两两比较相邻元素的值，若为逆序(即A[i-1]&gt;A[i])，则交换它们，直到序列比较完。我们称它为一.趟冒泡，结果将最小的元素交换到待排序列的第一一个位置(关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”，这就是冒泡排序名字的由来)。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少-一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，…..  这样最多做n-1趟冒泡就能把所有元素排好序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i,j;</span><br><span class="line">	<span class="keyword">bool</span> flag;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">		flag = <span class="literal">false</span>;        <span class="comment">//flag用来标记此趟排序是否发生了交换</span></span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(R[j<span class="number">-1</span>] &gt; R[j])&#123;</span><br><span class="line">				temp = R[j];</span><br><span class="line">				R[j] = R[j<span class="number">-1</span>];</span><br><span class="line">				R[j<span class="number">-1</span>] = temp;</span><br><span class="line">				flag = <span class="literal">true</span>;  <span class="comment">//如果没发生交换，则flag为0</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag)&#123;      <span class="comment">//一趟排序过程中没有发生排序，则证明剩余序列有序，不在冒泡</span></span><br><span class="line">			outPutArr(R,n);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h2><blockquote>
<p><strong><em>算法思想</em></strong>：也是交换类的排序，它通过多次划分操作实现排序。以升序为例，其执行流程可以概括为：每一趟选择当前所有子序列中的一个关键字(通常是第一个)作为枢轴，将子序列中比枢轴小的移到枢轴的前边，比枢轴大的移动到枢轴的后边；当本趟所有的子序列都被枢轴以上述规则划分完毕后会的到新的一组更短的子序列，它们成为下一趟划分的初始序列集。快速排序的算法思想基于分治思想的，其平均时间复杂度为O(n*logn)，最坏时间复杂度为O(n^2)。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">int</span> i = low, j = high;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">		temp = R[low];</span><br><span class="line">		<span class="keyword">while</span>(i &lt; j)&#123;   <span class="comment">//将数组中小于temp的放在左边，大于temp的放在右边</span></span><br><span class="line">			<span class="keyword">while</span>(j &gt; i &amp;&amp; R[j] &gt;= temp)&#123;   <span class="comment">//从右往左扫描，找到一个小于temp的关键字</span></span><br><span class="line">				j--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">				R[i] = R[j];         <span class="comment">//放在temp左边</span></span><br><span class="line">				i++;                 <span class="comment">//右移一位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(i &lt; j &amp;&amp; R[i] &lt; temp)&#123;    <span class="comment">//从左往右扫描，找到一个大于temp的关键字</span></span><br><span class="line">				i++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">				R[j] = R[i];        <span class="comment">//放在temp右边</span></span><br><span class="line">				j--;                <span class="comment">//左移一位</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		R[i] = temp;                <span class="comment">//将temp放在最终位置</span></span><br><span class="line">		quickSort(R,low,i<span class="number">-1</span>);       <span class="comment">//递归的对temp左边的关键字排序</span></span><br><span class="line">		quickSort(R,i+<span class="number">1</span>,high);      <span class="comment">//递归的对temp右边的关键字排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="5、简单选择排序"><a href="#5、简单选择排序" class="headerlink" title="5、简单选择排序"></a>5、简单选择排序</h2><blockquote>
<p><strong><em>算法思想</em></strong>：选择类排序的主要动作是“选择”。简单选择采用最简单的选择方式，从头至尾扫描序列，选出最小的一个关键字，和第一个关键字交换，接着从剩下的关键字中继续这种选择和交换，最终使序列有序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		k = i;</span><br><span class="line">		<span class="comment">/*下面这个循环是算法的关键，它从无序序列中挑出一个最小的关键字*/</span></span><br><span class="line">		<span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(R[k] &gt; R[j])&#123;</span><br><span class="line">				k = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*下面这三句完成最小关键字与无序序列第一个关键字的交换*/</span></span><br><span class="line">		temp = R[i];</span><br><span class="line">		R[i] = R[k];</span><br><span class="line">		R[k] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	outPutArr(R,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6、堆排序"><a href="#6、堆排序" class="headerlink" title="6、堆排序"></a>6、堆排序</h2><blockquote>
<p><strong><em>算法思想</em></strong>：堆是一种完全二叉树,这颗二叉树满足：任何一个非叶结点的值都不大于(或小于)其左右孩子结点的值。若父亲大孩子小，这样的堆称之为大顶堆；若父亲小孩子大称为小根堆。根据堆的定义可以知道，代表堆的这颗完全二叉树的根结点是最大的(或者最小的)，因此将一个无序的序列调整为一个堆，就可以找到这个序列的最大值(或者最小)的值，然后将找出的值交换到这个序列的最后(或最前)，这样有序序列关键字增加1个，无序序列中的关键字减少1个，对新的无序序列重复这样的操作，就实现了排序。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">堆排序算法主方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(i = n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;      <span class="comment">//建立初始堆</span></span><br><span class="line">		sift(R, i, n<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;        <span class="comment">//进行n-1次循环，完成堆排序</span></span><br><span class="line">		temp = R[<span class="number">0</span>];             <span class="comment">//一下3句换出根节点的关键字，将其放入最终位置</span></span><br><span class="line">		R[<span class="number">0</span>] = R[i];</span><br><span class="line">		R[i] = temp;</span><br><span class="line">		sift(R, <span class="number">0</span>, i<span class="number">-1</span>);           <span class="comment">//在减少了一个关键字的无序序列中调整</span></span><br><span class="line">	&#125;</span><br><span class="line">	outPutArr(R, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">堆的局部调整方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift</span><span class="params">(<span class="keyword">int</span> R[] ,<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;      <span class="comment">//关键字设定下表从0开始</span></span><br><span class="line">	<span class="keyword">int</span> i = low,j = <span class="number">2</span>*i + <span class="number">1</span>;                 <span class="comment">//R[j]是R[i]的左孩子节点</span></span><br><span class="line">	<span class="keyword">int</span> temp = R[i];</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">		<span class="keyword">if</span>(j &lt; high &amp;&amp; R[j] &lt; R[j+<span class="number">1</span>])&#123;         <span class="comment">//若右孩子较大，则j指向右孩子</span></span><br><span class="line">			j++;                           <span class="comment">//j变为2*i+2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(temp &lt; R[j])&#123;</span><br><span class="line">			R[i] = R[j];                  <span class="comment">//将R[j]调整到双亲节点的位置</span></span><br><span class="line">			i = j;                        <span class="comment">//修改i和j的值，继续向下调整</span></span><br><span class="line">			j = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">break</span>;                       <span class="comment">//调整结束</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	R[i] = temp;                         <span class="comment">//被调整节点放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="7、归并排序"><a href="#7、归并排序" class="headerlink" title="7、归并排序"></a>7、归并排序</h2><blockquote>
<p><strong><em>算法思想</em></strong>：二路归并排序是采用的分而治之的思想。将一个待排序的序列分成两个序列，分别对这两个序列排序。而对于这两个序列排序的方式也是和之前一样，将这两个序列分别分成两个序列分别排序。一直这样分割下去，知道序列中没有元素或者只有一个元素为止。因为没有元素的序列和只有一个元素的序列定是一个有序的序列，所以相当于将这个序列排序完毕，向上返回。返回的过程中做的最重要的一件事就是将两个有序的序列合并成一个有序的序列。所以归并排序最重要的两步是分割和合并。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**归并排序主方法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">		mergeSort(R, low, mid);       <span class="comment">//归并排序前半段</span></span><br><span class="line">		mergeSort(R, mid + <span class="number">1</span>, high);    <span class="comment">//归并排序后半段</span></span><br><span class="line">		merge(R, low, mid, high);    <span class="comment">//将R数组中low~mid,mid~high两段序列归并为一个序列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**将两个序列归并为一个有序序列*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> R[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">int</span> n1 = mid - low + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> n2 = high - mid;</span><br><span class="line">	<span class="keyword">int</span> left[n1], right[n2];    <span class="comment">//此处在C++和C里会有编译错误，解决办法是将测试用例的逻辑结构改为一般线性表或者用Java语言实现该算法</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n1; i++)&#123;</span><br><span class="line">		left[i] = R[low + i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n2; j++)&#123;</span><br><span class="line">		right[j] = R[mid + <span class="number">1</span> + j];</span><br><span class="line">	&#125;</span><br><span class="line">	i = <span class="number">0</span>; j = <span class="number">0</span>; k = low;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; n1 &amp;&amp; j &lt; n2)&#123;</span><br><span class="line">		<span class="keyword">if</span>(left[i] &lt;= right[j])&#123;</span><br><span class="line">			R[k] = left[i++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			R[k] = right[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n1)&#123;</span><br><span class="line">		R[k++] = left[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;n2)&#123;</span><br><span class="line">		R[k++] = right[j++];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><blockquote><p>Original author: Chengxin Li</p><p>Original link: <a href="https://blog.eaglelee.cn/2019/12/14/Sort Algorithm/">https://blog.eaglelee.cn/2019/12/14/Sort Algorithm/</a></p><p>Copyright Notice: Please indicate the source of the reprint (must retain the author's signature and link)</p></blockquote></div><div class="tags"><a href="/tags/Sort/">Sort</a><a href="/tags/Algorithm/">Algorithm</a></div><div class="post-share"><div class="social-share"><span>Share:</span></div></div><div class="post-nav"><a href="/2020/02/19/Git%20Notes/" class="pre">Git Note</a><a href="/2019/11/29/README-Hexo/" class="next">The README of BlueLake</a></div><div id="comments"><div id="container"><script type="text/javascript" src="https://unpkg.com/gitalk/dist/gitalk.min.js?v=2.0.4"></script><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=2.0.4"></script><script>var gitalk = new Gitalk({
  clientID: 'e15a03cff387f79dff2a',
  clientSecret: 'c89fe808ce6a75754abeff85be46ad8937de0314',
  repo: 'BitEagle09.github.io',
  owner: 'BitEagle09',
  admin: ['BitEagle09'],
  id: md5(window.location.pathname),
  distractionFreeMode: false,
  language: 'en',
  pagerDirection: 'last'
})
gitalk.render('container')</script></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Contents</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#排序算法-考研数据结构"><span class="toc-text">排序算法-考研数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0、各排序算法的时间复杂度与空间复杂度及稳定性比较"><span class="toc-text">0、各排序算法的时间复杂度与空间复杂度及稳定性比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1、直接插入"><span class="toc-text">1、直接插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、希尔排序"><span class="toc-text">2、希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、冒泡排序"><span class="toc-text">3、冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、快速排序"><span class="toc-text">4、快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、简单选择排序"><span class="toc-text">5、简单选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、堆排序"><span class="toc-text">6、堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、归并排序"><span class="toc-text">7、归并排序</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/07/Python3%E6%93%8D%E4%BD%9CSQLite3/">Python3操作SQLite3</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/19/Git%20Notes/">Git Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/14/Sort%20Algorithm/">Sort Algorithm</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/README-Hexo/">The README of BlueLake</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/20/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"><a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Note/" style="font-size: 15px;">Note</a> <a href="/tags/python3/" style="font-size: 15px;">python3</a> <a href="/tags/sqlite3/" style="font-size: 15px;">sqlite3</a> <a href="/tags/HelloWorld/" style="font-size: 15px;">HelloWorld</a> <a href="/tags/Sort/" style="font-size: 15px;">Sort</a> <a href="/tags/Algorithm/" style="font-size: 15px;">Algorithm</a> <a href="/tags/README/" style="font-size: 15px;">README</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archive</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/">2019</a><span class="archive-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.yinwang.org" title="Yin Wang" target="_blank">Yin Wang</a><ul></ul><a href="http://blog.codinglabs.org" title="CodingLabs" target="_blank">CodingLabs</a><ul></ul><a href="http://www.snowball.chat" title="SnowBall's Cafe" target="_blank">SnowBall's Cafe</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Site Map</a> |  <a href="/atom.xml">Subscribe to this site</a> |  <a href="/about/">Contact the blogger</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Chengxin Li.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>